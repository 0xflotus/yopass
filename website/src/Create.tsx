import * as React from 'react';
import { useState } from 'react';
import {
  Alert,
  Button,
  Form,
  FormGroup,
  FormText,
  Input,
  Label,
  InputGroup,
  InputGroupAddon,
  InputGroupText,
} from 'reactstrap';

import './Create.scss';
import Result from './Result';
import { encryptMessage, postSecret, randomString } from './utils';
import { useTranslation } from 'react-i18next';

const Create = () => {
  const [expiration, setExpiration] = useState(3600);
  const [error, setError] = useState('');
  const [secret, setSecret] = useState('');
  const [onetime, setOnetime] = useState(true);
  const [loading, setLoading] = useState(false);
  const [uuid, setUUID] = useState('');
  const [password, setPassword] = useState('');
  const [specifyPassword, setSpecifyPassword] = useState(false);

  const { t } = useTranslation();

  const submit = async () => {
    if (!secret) {
      return;
    }
    setLoading(true);
    setError('');
    try {
      // Use the manually entered password, or generate one
      const pw = password.length ? password : randomString();
      const { data, status } = await postSecret({
        expiration,
        message: await encryptMessage(secret, pw),
        one_time: onetime,
      });
      if (status !== 200) {
        setError(data.message);
      } else {
        setUUID(data.message);
        setPassword(pw);
      }
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  };

  const setSpecifyPasswordAndUpdatePassword = (newValue: boolean) => {
    setSpecifyPassword(newValue);

    if (!newValue) {
      // Clear the manual password if it should be generated.
      setPassword('');
    }
  };

  return (
    <div className="text-center">
      <h1>{t("Encrypt message")}</h1>
      <Error message={error} onClick={() => setError('')} />
      {uuid ? (
        <Result uuid={uuid} password={password} prefix="s" />
      ) : (
          <Form>
            <FormGroup>
              <Label for="secret">{t("Secret message")}</Label>
              <Input
                type="textarea"
                id="secret"
                name="secret"
                rows="4"
                autoFocus={true}
                placeholder={t("Message to encrypt locally in your browser")}
                onChange={e => setSecret(e.target.value)}
                value={secret}
              />

              <Label for="password">{t("Decryption Key")}</Label>
              <FormText className="muted">{t("The decryption key is randomly generated by default")}</FormText>
              <InputGroup>
                <InputGroupAddon addonType="prepend">
                  <InputGroupText>
                    <Input
                      id="manual-password"
                      addon
                      type="checkbox"
                      checked={specifyPassword}
                      onChange={e => setSpecifyPasswordAndUpdatePassword(e.target.checked)}
                      aria-label={t("Checkbox for toggling manual decryption key input")} />

                    <Label
                      id="label-for-manual-password"
                      for="manual-password"
                    >{t("Enable")}</Label>
                  </InputGroupText>
                </InputGroupAddon>

                <Input
                  type="text"
                  id="password"
                  name="password"
                  placeholder={t("Manually enter password")}
                  disabled={!specifyPassword}
                  onChange={e => setPassword(e.target.value)}
                  value={password}
                />
              </InputGroup>

            </FormGroup>
            <Lifetime expiration={expiration} setExpiration={setExpiration} />
            <OneTime setOnetime={setOnetime} onetime={onetime} />
            <Button
              disabled={loading || secret.length === 0 || (specifyPassword && password.length === 0)}
              color="primary"
              size="lg"
              block={true}
              onClick={() => submit()}
            >
              {loading ? (
                <span>{t("Encrypting message...")}</span>
              ) : (
                  <span>{t("Encrypt Message")}</span>
                )}
            </Button>
          </Form>
        )}
    </div>
  );
};

export const OneTime = (
  props: {
    readonly onetime: boolean;
    readonly setOnetime: React.Dispatch<React.SetStateAction<boolean>>;
  } & React.HTMLAttributes<HTMLElement>,
) => {
  const { t } = useTranslation();
  const { onetime, setOnetime } = props;
  return (
    <FormGroup>
      <Input
        type="checkbox"
        onChange={() => setOnetime(!onetime)}
        checked={onetime}
      />
      {t("One-time download")}
    </FormGroup>
  );
};
export const Lifetime = (
  props: {
    readonly expiration: number;
    readonly setExpiration: React.Dispatch<React.SetStateAction<number>>;
  } & React.HTMLAttributes<HTMLElement>,
) => {
  const { expiration, setExpiration } = props;
  const { t } = useTranslation();
  const buttons = [];
  for (const i of [
    {
      duration: 3600,
      name: '1h',
      text: t("One Hour"),
    },
    {
      duration: 86400,
      name: '1d',
      text: t("One Day"),
    },
    {
      duration: 604800,
      name: '1w',
      text: t("One Week"),
    },
  ]) {
    buttons.push(
      <FormGroup key={i.name} check={true} inline={true}>
        <Label check={true}>
          <Input
            type="radio"
            name={i.name}
            value={i.duration}
            onChange={e => setExpiration(+e.target.value)}
            checked={expiration === i.duration}
          />
          {i.text}
        </Label>
      </FormGroup>,
    );
  }

  return (
    <FormGroup tag="fieldset">
      <FormText color="muted">
        {t("The encrypted message will be deleted automatically after")}
      </FormText>
      {buttons}
    </FormGroup>
  );
};

export const Error = (
  props: { readonly message: string } & React.HTMLAttributes<HTMLElement>,
) =>
  props.message ? (
    <Alert color="danger" {...props}>
      {props.message}
    </Alert>
  ) : null;

export default Create;
